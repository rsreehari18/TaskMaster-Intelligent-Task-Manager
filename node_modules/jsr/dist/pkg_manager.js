"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPkgManager = exports.Bun = exports.YarnBerry = void 0;
// Copyright 2024 the JSR authors. MIT license.
const api_1 = require("./api");
const utils_1 = require("./utils");
const kl = require("kolorist");
async function execWithLog(cmd, args, cwd) {
    console.log(kl.dim(`$ ${cmd} ${args.join(" ")}`));
    return (0, utils_1.exec)(cmd, args, cwd);
}
function modeToFlag(mode) {
    return mode === "dev"
        ? "--save-dev"
        : mode === "optional"
            ? "--save-optional"
            : "";
}
function modeToFlagYarn(mode) {
    return mode === "dev" ? "--dev" : mode === "optional" ? "--optional" : "";
}
function toPackageArgs(pkgs) {
    return pkgs.map((pkg) => `@${pkg.scope}/${pkg.name}@npm:${pkg.toNpmPackage()}`);
}
async function isYarnBerry(cwd) {
    // this command works for both yarn classic and berry
    const version = await (0, utils_1.exec)("yarn", ["--version"], cwd, undefined, true);
    if (!version) {
        (0, utils_1.logDebug)("Unable to detect yarn version, assuming classic");
        return false;
    }
    if (version.startsWith("1.")) {
        (0, utils_1.logDebug)("Detected yarn classic from version");
        return false;
    }
    (0, utils_1.logDebug)("Detected yarn berry from version");
    return true;
}
class Npm {
    cwd;
    constructor(cwd) {
        this.cwd = cwd;
    }
    async install(packages, options) {
        const args = ["install"];
        const mode = modeToFlag(options.mode);
        if (mode !== "") {
            args.push(mode);
        }
        args.push(...toPackageArgs(packages));
        await execWithLog("npm", args, this.cwd);
    }
    async remove(packages) {
        await execWithLog("npm", ["remove", ...packages.map((pkg) => pkg.toString())], this.cwd);
    }
    async runScript(script) {
        await execWithLog("npm", ["run", script], this.cwd);
    }
}
class Yarn {
    cwd;
    constructor(cwd) {
        this.cwd = cwd;
    }
    async install(packages, options) {
        const args = ["add"];
        const mode = modeToFlagYarn(options.mode);
        if (mode !== "") {
            args.push(mode);
        }
        args.push(...toPackageArgs(packages));
        await execWithLog("yarn", args, this.cwd);
    }
    async remove(packages) {
        await execWithLog("yarn", ["remove", ...packages.map((pkg) => pkg.toString())], this.cwd);
    }
    async runScript(script) {
        await execWithLog("yarn", [script], this.cwd);
    }
}
class YarnBerry extends Yarn {
    async install(packages, options) {
        const args = ["add"];
        const mode = modeToFlagYarn(options.mode);
        if (mode !== "") {
            args.push(mode);
        }
        args.push(...(await this.toPackageArgs(packages)));
        await execWithLog("yarn", args, this.cwd);
    }
    /**
     * Calls the `yarn config set` command, https://yarnpkg.com/cli/config/set.
     */
    async setConfigValue(key, value) {
        await execWithLog("yarn", ["config", "set", key, value], this.cwd);
    }
    async toPackageArgs(pkgs) {
        // nasty workaround for https://github.com/yarnpkg/berry/issues/1816
        await Promise.all(pkgs.map(async (pkg) => {
            pkg.version ??= `^${await (0, api_1.getLatestPackageVersion)(pkg)}`;
        }));
        return toPackageArgs(pkgs);
    }
}
exports.YarnBerry = YarnBerry;
class Pnpm {
    cwd;
    constructor(cwd) {
        this.cwd = cwd;
    }
    async install(packages, options) {
        const args = ["add"];
        const mode = modeToFlag(options.mode);
        if (mode !== "") {
            args.push(mode);
        }
        args.push(...toPackageArgs(packages));
        await execWithLog("pnpm", args, this.cwd);
    }
    async remove(packages) {
        await execWithLog("pnpm", ["remove", ...packages.map((pkg) => pkg.toString())], this.cwd);
    }
    async runScript(script) {
        await execWithLog("pnpm", [script], this.cwd);
    }
}
class Bun {
    cwd;
    constructor(cwd) {
        this.cwd = cwd;
    }
    async install(packages, options) {
        const args = ["add"];
        const mode = modeToFlagYarn(options.mode);
        if (mode !== "") {
            args.push(mode);
        }
        args.push(...toPackageArgs(packages));
        await execWithLog("bun", args, this.cwd);
    }
    async remove(packages) {
        await execWithLog("bun", ["remove", ...packages.map((pkg) => pkg.toString())], this.cwd);
    }
    async runScript(script) {
        await execWithLog("bun", ["run", script], this.cwd);
    }
}
exports.Bun = Bun;
function getPkgManagerFromEnv(value) {
    if (value.startsWith("pnpm/"))
        return "pnpm";
    else if (value.startsWith("yarn/"))
        return "yarn";
    else if (value.startsWith("npm/"))
        return "npm";
    else if (value.startsWith("bun/"))
        return "bun";
    else
        return null;
}
async function getPkgManager(cwd, pkgManagerName) {
    const envPkgManager = process.env.npm_config_user_agent;
    const fromEnv = envPkgManager !== undefined
        ? getPkgManagerFromEnv(envPkgManager)
        : null;
    const { projectDir, pkgManagerName: fromLockfile, root } = await (0, utils_1.findProjectDir)(cwd);
    const rootPath = root || projectDir;
    const result = pkgManagerName || fromEnv || fromLockfile || "npm";
    let pkgManager;
    if (result === "yarn") {
        pkgManager = await isYarnBerry(projectDir)
            ? new YarnBerry(projectDir)
            : new Yarn(projectDir);
    }
    else if (result === "pnpm") {
        pkgManager = new Pnpm(projectDir);
    }
    else if (result === "bun") {
        pkgManager = new Bun(projectDir);
    }
    else {
        pkgManager = new Npm(projectDir);
    }
    return { root: rootPath, pkgManager };
}
exports.getPkgManager = getPkgManager;
//# sourceMappingURL=pkg_manager.js.map