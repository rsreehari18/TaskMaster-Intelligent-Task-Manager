"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.showPackageInfo = exports.runScript = exports.publish = exports.remove = exports.install = exports.setupBunfigToml = exports.setupNpmRc = void 0;
// Copyright 2024 the JSR authors. MIT license.
const path = __importStar(require("node:path"));
const fs = __importStar(require("node:fs"));
const kl = __importStar(require("kolorist"));
const utils_1 = require("./utils");
const pkg_manager_1 = require("./pkg_manager");
const download_1 = require("./download");
const api_1 = require("./api");
const semiver_1 = __importDefault(require("semiver"));
const NPMRC_FILE = ".npmrc";
const BUNFIG_FILE = "bunfig.toml";
const JSR_NPM_REGISTRY_URL = "https://npm.jsr.io";
const JSR_NPMRC = `@jsr:registry=${JSR_NPM_REGISTRY_URL}\n`;
const JSR_BUNFIG = `[install.scopes]\n"@jsr" = "${JSR_NPM_REGISTRY_URL}"\n`;
const JSR_YARN_BERRY_CONFIG_KEY = "npmScopes.jsr.npmRegistryServer";
async function wrapWithStatus(msg, fn) {
    process.stdout.write(msg + "...");
    try {
        await fn();
        process.stdout.write(kl.green("ok") + "\n");
    }
    catch (err) {
        process.stdout.write(kl.red("error") + "\n");
        throw err;
    }
}
async function setupNpmRc(dir) {
    const npmRcPath = path.join(dir, NPMRC_FILE);
    const msg = `Setting up ${NPMRC_FILE}`;
    try {
        let content = await fs.promises.readFile(npmRcPath, "utf-8");
        if (!content.includes("@jsr:registry=")) {
            const nl = (0, utils_1.getNewLineChars)(content);
            const spacer = (!content.endsWith(nl)) ? nl : "";
            content += spacer + JSR_NPMRC;
            await wrapWithStatus(msg, async () => {
                await fs.promises.writeFile(npmRcPath, content);
            });
        }
    }
    catch (err) {
        if (err instanceof Error && err.code === "ENOENT") {
            await wrapWithStatus(msg, async () => {
                await fs.promises.writeFile(npmRcPath, JSR_NPMRC);
            });
        }
        else {
            throw err;
        }
    }
}
exports.setupNpmRc = setupNpmRc;
async function setupBunfigToml(dir) {
    const bunfigPath = path.join(dir, BUNFIG_FILE);
    const msg = `Setting up ${BUNFIG_FILE}`;
    try {
        let content = await fs.promises.readFile(bunfigPath, "utf-8");
        if (!/^"@jsr"\s+=/gm.test(content)) {
            content += JSR_BUNFIG;
            await wrapWithStatus(msg, async () => {
                await fs.promises.writeFile(bunfigPath, content);
            });
        }
    }
    catch (err) {
        if (err instanceof Error && err.code === "ENOENT") {
            await wrapWithStatus(msg, async () => {
                await fs.promises.writeFile(bunfigPath, JSR_BUNFIG);
            });
        }
        else {
            throw err;
        }
    }
}
exports.setupBunfigToml = setupBunfigToml;
async function install(packages, options) {
    const { pkgManager, root } = await (0, pkg_manager_1.getPkgManager)(process.cwd(), options.pkgManagerName);
    if (packages.length > 0) {
        if (pkgManager instanceof pkg_manager_1.Bun) {
            // Bun doesn't support reading from .npmrc yet
            await setupBunfigToml(root);
        }
        else if (pkgManager instanceof pkg_manager_1.YarnBerry) {
            // Yarn v2+ does not read from .npmrc intentionally
            // https://yarnpkg.com/migration/guide#update-your-configuration-to-the-new-settings
            await pkgManager.setConfigValue(JSR_YARN_BERRY_CONFIG_KEY, JSR_NPM_REGISTRY_URL);
        }
        else {
            await setupNpmRc(root);
        }
        console.log(`Installing ${kl.cyan(packages.join(", "))}...`);
    }
    await pkgManager.install(packages, options);
}
exports.install = install;
async function remove(packages, options) {
    const { pkgManager } = await (0, pkg_manager_1.getPkgManager)(process.cwd(), options.pkgManagerName);
    console.log(`Removing ${kl.cyan(packages.join(", "))}...`);
    await pkgManager.remove(packages);
}
exports.remove = remove;
async function getOrDownloadBinPath(binFolder) {
    const info = await (0, download_1.getDenoDownloadUrl)();
    const binPath = path.join(binFolder, info.version, 
    // Ensure each binary has their own folder to avoid overwriting it
    // in case jsr gets added to a project as a dependency where
    // developers use multiple OSes
    process.platform, process.platform === "win32" ? "deno.exe" : "deno");
    // Check if deno executable is available, download it if not.
    if (!(await (0, utils_1.fileExists)(binPath))) {
        // Clear folder first to get rid of old download artifacts
        // to avoid taking up lots of disk space.
        try {
            await fs.promises.rm(binFolder, { recursive: true });
        }
        catch (err) {
            if (!(err instanceof Error) || err.code !== "ENOENT") {
                throw err;
            }
        }
        await (0, download_1.downloadDeno)(binPath, info);
    }
    return binPath;
}
async function publish(cwd, options) {
    const binPath = process.env.DENO_BIN_PATH ??
        await getOrDownloadBinPath(options.binFolder);
    // Ready to publish now!
    const args = [
        "publish",
    ];
    const env = { ...process.env };
    // These commands should only be added for a node project,
    // not a Deno project.
    if (options.pkgJsonPath !== null) {
        args.push("--unstable-bare-node-builtins", "--unstable-sloppy-imports", "--unstable-byonm", "--no-check");
        env.DENO_DISABLE_PEDANTIC_NODE_WARNINGS = "true";
    }
    args.push(...options.publishArgs.filter((arg) => arg !== "--verbose"));
    await (0, utils_1.exec)(binPath, args, cwd, env);
}
exports.publish = publish;
async function runScript(cwd, script, options) {
    const { pkgManager } = await (0, pkg_manager_1.getPkgManager)(cwd, options.pkgManagerName);
    await pkgManager.runScript(script);
}
exports.runScript = runScript;
async function showPackageInfo(raw) {
    const pkg = utils_1.JsrPackage.from(raw);
    const meta = await (0, api_1.getPackageMeta)(pkg);
    if (pkg.version === null) {
        let latest = meta.latest;
        if (latest === undefined) {
            throw new Error(`Missing latest version for ${pkg}`);
        }
        else if (latest === null) {
            // When no stable version is published: `latest === null`. We need to
            // manually find the latest pre-release version
            const versions = Object.keys(meta.versions);
            if (versions.length === 0) {
                throw new Error(`Could not find published version for ${pkg}`);
            }
            versions.sort(semiver_1.default);
            pkg.version = versions[0];
        }
        else {
            pkg.version = latest;
        }
    }
    const versionCount = Object.keys(meta.versions).length;
    const npmInfo = await (0, api_1.getNpmPackageInfo)(pkg);
    const versionInfo = npmInfo.versions[pkg.version];
    const time = npmInfo.time[pkg.version];
    const publishTime = new Date(time).getTime();
    console.log();
    console.log(kl.cyan(`@${pkg.scope}/${pkg.name}@${pkg.version}`) +
        ` | latest: ${kl.magenta(meta.latest ?? "-")} | versions: ${kl.magenta(versionCount)}`);
    console.log(npmInfo.description);
    console.log();
    console.log(`npm tarball:   ${kl.cyan(versionInfo.dist.tarball)}`);
    console.log(`npm integrity: ${kl.cyan(versionInfo.dist.integrity)}`);
    console.log();
    console.log(`published: ${kl.magenta((0, utils_1.timeAgo)(Date.now() - publishTime))}`);
}
exports.showPackageInfo = showPackageInfo;
//# sourceMappingURL=commands.js.map